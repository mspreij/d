# list all files modified within the last day (+1 for before last day, 1 for exactly 24 hours ago)
$ find . -mtime -1 -ls
# -mmin for minutes ago/before/etc

# find files owned by specific user or group
$ find . -user joe -group developers
# (yeah, try and remember THAT)

# find files with extension foo, note the wildcard AND the quotes because why make things simple
$ find . -name '*foo'

# find files except not in /that/ directory (note, again, the quotes and slashes and wildcard..)
$ find . -name '*php' -not -path './vendor/*'
# although the second slash is technically optional. possibly. depending, probably.

# find files matching this or that, except not in /that/ directory
$ find . \( -name '*php' -o -name '*json' \) -not -path './vendor/*'
# the -o is an OR, and the escaped () group the name matches to logically separate both from the directory filter

# find links
$ find . -type l
# pipe to xargs realpath to get the sources

# find _broken_ links
$ find . -xtype l

# simple function searching current and sub-directories for case-insensitive substring match
f ()
{
    if [[ "$1" = '' ]]; then
        echo '  Finds files in current (sub)directory containing given substring. Usage: $ f <substring>';
        echo "  Implemented as: $ find . -iname \"*\$1*\" -not -path './.git/*' | cut -b 3-;";
        echo "  It works mostly.";
        return;
    fi;
    find . -iname "*$1*" -not -path './.git/*' | cut -b 3-
}

There are modern `find` alternatives, I'll list 'm when I ..find 'm.

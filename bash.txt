Scripting cheatsheet: https://devhints.io/bash

### looping through lines (from a textfile, say)
# read splits a line into columns on whitespace.
# read -a turns line into an array.
while read -a line; do echo ${line[0]}${line[1]}; done < file.txt
# alternatively..
cat file.txt | while read -a line; do echo ${line[0]}${line[1]}; done

# use "read foo bar bazz" to read the first 3 words (columns) into those variables.
# the last variable always gets Everything until EOL, dump that in a '_' variable to ignore
while read foo bar _; do things with ${foo} and to ${bar}; done < file.txt # only interested in the first two columns

# is my script being piped?
-t fd # True if file descriptor fd is open and refers to a terminal.
# fd can be one of the usual file descriptor assignments: 0 stdin, 1 stdout, 2 stderr
$ if [[ -t 1 ]] ; then echo terminal; else echo "not a terminal"; fi

# shortest way to increment a variable (note no '$')
((i++))

# redirecting output.
$ foo >/dev/null 2>&1
# > : redirects STDOUT (the default), which would usually point to the terminal (or parent process), to /dev/null
# 2>&1 : 2, aka STDERR, goes to where 1 (STDOUT) _now_ points, so also to /dev/null. & to indicate "not a file named 1"
# it's more useful to read 2>&1 as "errors go to where stdout is currently going" then "errors go to stdout"
$ foo 2>&1 >/dev/null
# in a different order: STDERR now goes to what STDOUT points at: the terminal or parent process
# Then, STDOUT is pointed at /dev/null, but this no longer affects error messages.
# ..... SOMETHING like that, anyway o.o;

Scripting cheatsheet: https://devhints.io/bash

### looping through lines (from a textfile, say)
# read splits a line into columns on whitespace.
# read -a turns line into an array.
while read -a line; do echo ${line[0]}${line[1]}; done < file.txt
# alternatively..
cat file.txt | while read -a line; do echo ${line[0]}${line[1]}; done

# use "read foo bar bazz" to read the first 3 words (columns) into those variables.
# the last variable always gets Everything until EOL, dump that in a '_' variable to ignore
while read foo bar _; do things with ${foo} and to ${bar}; done < file.txt # only interested in the first two columns

### Is my script being piped?
-t fd # True if file descriptor fd is open and refers to a terminal.
# fd can be one of the usual file descriptor assignments: 0 stdin, 1 stdout, 2 stderr
$ if [[ -t 1 ]] ; then echo "output is a terminal"; else echo "output is Not a terminal"; fi
# also works for detecting whether input came from the user, or another script/process (fd=0)

### Is my script running from crontab?
`tty -s` has a non-zero exit status $? when the script is running from cron (tty returns the name of the terminal
    connected to STDIN, which won't exist. -s surpresses output)

# shortest way to increment a variable (note no '$')
((i++))

# what's the deal with export?
export foo[=bar]
Basically it turns a regular variable into an environment variable, which means it gets copied to nested shells and
scripts. Some variables (like $TERM) are environment variables already and don't require an export when changing them.

# redirecting output.
$ foo >/dev/null 2>&1
# > : redirects STDOUT (the default), which would usually point to the terminal (or parent process), to /dev/null
# 2>&1 : 2, aka STDERR, goes to where 1 (STDOUT) _now_ points, so also to /dev/null. & to indicate "not a file named 1"
# it's more useful to read 2>&1 as "errors go to where stdout is currently going" then "errors go to stdout"
$ foo 2>&1 >/dev/null
# in a different order: STDERR now goes to what STDOUT points at: the terminal or parent process
# Then, STDOUT is pointed at /dev/null, but this no longer affects error messages.
# ..... SOMETHING like that, anyway o.o;

# regex in `if` uses ERE, unrelated to the general shell glob patterns in eg `case`
if [[ "string" =~ regex ]]; then..
# do not quote the regex. if it's complicated, store it in a variable first and use that (unquoted).
# see http://mywiki.wooledge.org/BashGuide/Patterns for the ugl^H^Hseful details.
